<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多线程并发问题</title>
    <link href="/2021/06/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e532817f707795?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>新建状态（ NEW）：</strong> 线程刚创建, 尚未启动。<code>Thread thread = new Thread()</code>。</p><p><strong>可运行状态（RUNNABLE）：</strong> 线程对象创建后，其他线程(比如 main 线程）调用了该对象的 <code>start</code> 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。</p><p><strong>运行(running)：</strong> 线程获得 CPU 资源正在执行任务（<code>run()</code> 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p><p><strong>阻塞状态（Blocked）：</strong> 线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。</p><p><code>sleep</code>,<code>suspend</code>，<code>wait</code>等方法都可以导致线程阻塞。</p><p><strong>等待（WAITING）：</strong> 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p><strong>超时等待(TIMED_WAITING)：</strong> 该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</p><p><strong>终止(TERMINATED)：</strong> 表示该线程已经执行完毕，如果一个线程的<code>run</code>方法执行结束或者调用<code>stop</code>方法后，该线程就会死亡。对于已经死亡的线程，无法再使用<code>start</code>方法令其进入就绪。</p><h3 id="创建线程方式"><a href="#创建线程方式" class="headerlink" title="创建线程方式"></a>创建线程方式</h3><p>实现Runnable接口，重载<code>run()</code>，无返回值</p><p>继承Thread类，复写<code>run()</code></p><p>实现Callable接口，通过FutureTask/Future来创建有返回值的Thread线程，通过Executor执行</p><p>使用Executors创建ExecutorService，入参Callable或Future</p><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul><li>进程是资源申请、调度和独立运行的单位，是一个程序在其自身的地址空间中的一次执行活动,是系统运行程序的基本单位</li><li>线程又称为轻量级进程，它和进程一样拥有独立的执行控制，由操作系统负责调度，区 别在于线程没有独立的存储空间，而是和所属进程中的其它线程共享一个存储空间，这使得线程间的通信远较进程简单。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。（多个线程共享一个进程的堆和方法区）</li></ul><h3 id="Voliate"><a href="#Voliate" class="headerlink" title="Voliate"></a>Voliate</h3><p><strong>保证可见性</strong></p><blockquote><ol><li>当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中</li><li>这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见。</li></ol></blockquote><p><strong>禁止指令重排序</strong></p><p>1.它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>2.它会强制<strong>将缓存的修改操作立即写到主内存</strong></p><p>3.写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。</p><h1 id="多线程带来的问题"><a href="#多线程带来的问题" class="headerlink" title="多线程带来的问题"></a>多线程带来的问题</h1><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><p>所有线程的共享变量都存储在主内存中，每一个线程都有一个独有的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己的工作内存中，只操作工作内存中的数据。当修改完毕后，再把修改后的结果放回到主内存中。每个线程都只操作自己工作内存中的变量，无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p>如果有AB两个线程同时拿到变量i，进行递增操作。A线程将变量i放到自己的工作内存中，然后做+1操作，然而此时，线程A还没有将修改后的值刷回到主内存中，而此时线程B也从主内存中拿到修改前的变量i，也进行了一遍+1的操作。最后A和B线程将各自的结果分别刷回到主内存中，看到的结果就是变量i只进行了一遍+1的操作，而实际上A和B进行了两次累加的操作，于是就出现了错误。</p><h3 id="时序操作"><a href="#时序操作" class="headerlink" title="时序操作"></a>时序操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>    map.remove(obj)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码中首先检查 map 中有没有 key 对应的元素，如果有则继续执行 remove 操作。此时，这个组合操作就是危险的，因为它是先检查后操作，而执行过程中可能会被打断。如果此时有两个线程同时进入 if() 语句，然后它们都检查到存在 key 对应的元素，于是都希望执行下面的 remove 操作，随后一个线程率先把 obj 给删除了，而另外一个线程它刚已经检查过存在 key 对应的元素，if 条件成立，所以它也会继续执行删除 obj 的操作，但实际上，集合中的 obj 已经被前面的线程删除了，这种情况下就可能导致线程安全问题。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文 是指某一时间点 CPU 寄存器和程序计数器的内容</p><p>1.挂起一个线程 ，将这个线程程在 CPU 中的状态（上下文）存储于内存中的某处；</p><p>2.恢复一个线程，在内存中检索下一个线程的上下文并将其在 CPU 的寄存器中恢复；</p><p>3.跳转到程序计数器所指向的位置，（即跳转到线程被中断时的代码行），以恢复该线程。</p><ul><li><p>减少上下文切换的手段</p><blockquote><p>1.<strong>减少锁等待</strong>：锁等待意味着，线程频繁在活跃与等待状态之间切换，增加上下文切换，锁等待是由对同一份资源竞争激烈引起的，在一些场景我们可以用一些手段减轻锁竞争，比如<strong>数据分片</strong>或者数据快照等方式。</p><p>2.<strong>CAS算法</strong>：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；</p><p>3.<strong>使用合适的线程数量</strong>：N（thread）=N（cpu） * <strong>U（cpu）</strong>（CPU期望利用率）*（1+W/C)(W/C时等待事件/计算时间)。</p><p><strong>cpu密集型</strong>：加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。CPU个数的1-2倍，</p><p><strong>IO密集型</strong>：数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，远慢于CPU的运算速度，在等待IO时可以让出CPU资源。CPU个数的多倍。</p><p>4.<strong>使用协程</strong>：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；</p></blockquote></li></ul><h3 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h3><p>为提高读取效率，一次读取一个缓存行（64字节）到内存。（局部性原理）多线程情况下要保证缓存一致性。</p><p>Write invalidate（置无效）：当一个内核修改了一份数据，其他内核上如果有这份数据的复制，就置成无效。</p><p>Write update（写更新）：当一个内核修改了一份数据，其他地方如果有这份数据的复制，就都更新到最新值。</p><p><strong>伪共享问题</strong>：</p><p>在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去 竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要 使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p><h3 id="协作开销"><a href="#协作开销" class="headerlink" title="协作开销"></a>协作开销</h3><p>线程协作同样也有可能带来性能问题。因为线程之间如果有共享数据，为了避免数据错乱，为了保证线程安全，就有可能禁止编译器和 CPU 对其进行重排序等优化，也可能出于同步的目的，反复把线程工作内存的数据 flush 到主存中，然后再从主内存 refresh 到其他线程的工作内存中，等等。这些问题在单线程中并不存在，但在多线程中为了确保数据的正确性，就不得不采取上述方法，因为线程安全的优先级要比性能优先级更高，这也间接降低了我们的性能。</p><p>还有就是你在自己的代码实现中，为了线程安全添加了相应的逻辑，从而带来了相应的开销。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类的加载及对象创建分配的过程</title>
    <link href="/2021/06/08/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/06/08/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">int</span> staicVariabl=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//成员变量 （可以不进行初始化，如果进行初始化，成员变量的初始化动作在类层面完成，）</span><br>    <span class="hljs-keyword">public</span>   <span class="hljs-keyword">int</span>  objVariabl;<br><br>    <span class="hljs-comment">//静态初始代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        staicVariabl=<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//对象初始化代码块</span><br>    &#123;<br>        objVariabl=<span class="hljs-number">88</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>        objVariabl=<span class="hljs-number">99</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person person=<span class="hljs-keyword">new</span> Person();<br>    &#125;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="编译加载"><a href="#编译加载" class="headerlink" title="编译加载"></a>编译加载</h3><blockquote><p>经过编译后Person.java 会生成一个Person.class文件。Person.class经过加载后，会把类的相关信息加载到JVM内存中，解析出类的描述信息会保存到Metaspace。</p></blockquote><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p></blockquote><p>文件格式验证，元数据验证，字节码验证，符号引用验证。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p>给静态变量赋默认值，此时staicVariabl=0;准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述。Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。类的元数据（元数据并不是类的Class对象。Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的）才是存在方法区的。</p></blockquote><blockquote><p>这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p></blockquote><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标</li><li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li><li>多态的实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span> <span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类方法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sub1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;sub1方法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sub2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;sub2方法&quot;</span>);<br>    &#125;<br>&#125;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Parent parent;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        parent = <span class="hljs-keyword">new</span> sub2();<br>       parent.write();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>编译test类时用到了Parent类，</li><li> 此时不知道Parent类是否被加载，test类中存放了Parent类的符号引用。</li><li>到了test的解析阶段，使用到Parent类时，发现Parent类未被加载，将Parent类进行加载，将Parent的符号引用改为指向实际地址的直接引用。 </li><li>Parent类中有两个实现类，具体的引用该指向谁只有在发生调用时才会确定</li><li>通过后期绑定实现，类的动态解析，多态的具体实现。<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li></ol><blockquote><p>1、首先会对Person类的静态变量staicVariabl 进行真正的赋值的操作（此时staicVariabl =1）。</p></blockquote><blockquote><p>2、然后收集类的静态代码块内容，生成一个类的<clinit>() 方法并执行（此时staicVariabl =2）。</p></blockquote><h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><p>当我们new一个对象的时候JVM首先会去找到对应的类元信息，如果找不到意味着类信息还没有被加载，所以在对象创建的时候也可能会触发类的加载操作。当类元信息被加载之后，我们就可以通过类元信息来确定对象信息和需要申请的内存大小。</p><p>对象创建的流程<br>当我们执行上面代码中main方法中的的 Person person=new Person() 时，我们的对象就开始创建了，执行流程大致分为三步：</p><ol><li><p>构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。</p></li><li><p>初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法（init 方法执行完后objVariabl=88，构造方法执行完后objVariabl=99)。</p></li><li><p>引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。</p><p><strong>相应类加载检查过程</strong></p><blockquote><p>遇到new指令时，先检查指令参数是否能在常量池中定位到一个类的符号引用：<br>（A）、如果能定位到，检查这个符号引用代表的类是否已被加载、解析和初始化过；<br>（B）、如果不能定位到，或没有检查到，就先执行相应的类加载过程；</p></blockquote></li></ol><h3 id="在Java堆中为对象分配内存"><a href="#在Java堆中为对象分配内存" class="headerlink" title="在Java堆中为对象分配内存"></a>在Java堆中为对象分配内存</h3><p>   对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p><ul><li><p>内存规整，指针碰撞（Bump The Pointer）<br> 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一<br> 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</p></li><li><p>内存不规整，空闲列表（Free List）<br> 如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</p></li></ul><blockquote><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p></blockquote><p><strong>多线程下分配内存时的冲突问题</strong></p><p>   正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><ul><li><p>CAS<br> 一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</p></li><li><p>TLAB<br> 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p></li></ul><h3 id="分配后内存初始化为零"><a href="#分配后内存初始化为零" class="headerlink" title="分配后内存初始化为零"></a>分配后内存初始化为零</h3><p>   内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="对对象进行必要的设置"><a href="#对对象进行必要的设置" class="headerlink" title="对对象进行必要的设置"></a>对对象进行必要的设置</h3><p>   这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="执行对象实例方法init"><a href="#执行对象实例方法init" class="headerlink" title="执行对象实例方法init"></a>执行对象实例方法init</h3><p>   构造函数，即Class文件中的init()方法还没有执行new指令之后会接着执行init()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h2 id="对象在内存中的布局"><a href="#对象在内存中的布局" class="headerlink" title="对象在内存中的布局"></a>对象在内存中的布局</h2><p>   在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>   <img src="https://img-blog.csdnimg.cn/20210412204329726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul><li>Mark Word<br> 于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部<br> 分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。<br> 考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。<br> 例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0<br> <img src="https://img-blog.csdnimg.cn/20210412204409503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ul><li><p>类型指针<br> 对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例</p></li><li><p>数组长度<br> 数组对象才有，用来确定数组的大小。</p></li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>   对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>   仅仅起着占位符的作<br>   用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象访问的定位"><a href="#对象访问的定位" class="headerlink" title="对象访问的定位"></a>对象访问的定位</h2><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>   Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p>   <img src="https://img-blog.csdnimg.cn/20210412204445405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="file"></p><p>   使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><h3 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h3><p>   使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销</p><p>   <img src="https://img-blog.csdnimg.cn/20210412204459434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="file"></p><p>   使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就HotSpot而言，它主要使用第二种方式进行对象访问。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
