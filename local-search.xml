<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/2021/08/05/ElasticSearch/"/>
    <url>/2021/08/05/ElasticSearch/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="ES基础"><a href="#ES基础" class="headerlink" title="ES基础"></a>ES基础</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>bin 可执行脚本目录</p><p> config  配置目录：</p><p> elasticsearch.yml：elastic的相关配置（端口，跨域配置）<br> jvm.options：虚拟机相关配置（更改Xms，Xmx防止启动时内存不足）<br> log4j2.properties：日志配置</p><p> jdk 内置 JDK 目录</p><p> lib 类库 </p><p>logs 日志目录 </p><p>modules 模块目录</p><p> plugins 插件目录</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>数据格式</strong></p><p>index—文档—字段</p><p><strong>倒排索引</strong></p><p>倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。<br> 单词词典(Lexicon)：搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</p><p>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</p><p>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</p><p><img src="C:\Users\22106\AppData\Roaming\Typora\typora-user-images\image-20210725194017529.png" alt="image-20210725194017529"></p><ul><li>文档ID，用于获取原始信息</li><li>单词频率TF，记录该单词在该文档中的出现次数，用于后续相关性算分</li><li>位置Position，记录单词在文档中分词的位置，用于语句搜索(phrase query)</li><li>偏移Offset，记录单词在文档的开始和结束位置，实现高亮显示</li></ul><p><strong>RestFul</strong></p><p>每个资源有一个唯一地址，对资源的请求路径相同，通过不同的http请求完成不同的操作。</p><p>每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客 户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。 在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目 标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、 PUT、DELETE，还可能包括 HEAD 和 OPTIONS。简单的理解就是，如果想要访问互联 网上的资源，就必须向资源所在的服务器发出请求，请求体中必须包含资源的网络路径，以 及对资源进行的操作(增删改查)。</p><p><strong>用 URL 定位资源，用 HTTP 动词（GET，POST，DELETE，PUT）描述操作。</strong></p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><strong>创建/查看/删除索引</strong></li></ul><p>PUT/GET/DELETE  <a href="http://localhost:9200/shopping">http://localhost:9200/shopping</a></p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br><br>  <span class="hljs-attr">&quot;acknowledged&quot;</span>: **<span class="hljs-literal">true</span>**,  <span class="hljs-comment">//响应结果，成功</span><br><br>  <span class="hljs-attr">&quot;shards_acknowledged&quot;</span>: **<span class="hljs-literal">true</span>**,<span class="hljs-comment">//分片结果，成功</span><br> <br>  <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;shopping&quot;</span>             <span class="hljs-comment">//索引名称，shopping</span><br><br>&#125;<br><span class="hljs-comment">//查看索引</span><br>&#123;<br>    <span class="hljs-attr">&quot;shopping&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;aliases&quot;</span>: &#123;&#125;,<br>        <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;&#125;,<br>        <span class="hljs-attr">&quot;settings&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;index&quot;</span>: &#123;<br>                <span class="hljs-attr">&quot;creation_date&quot;</span>: <span class="hljs-string">&quot;1626616593650&quot;</span>,<br>                <span class="hljs-attr">&quot;number_of_shards&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>                <span class="hljs-attr">&quot;number_of_replicas&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>                <span class="hljs-attr">&quot;uuid&quot;</span>: <span class="hljs-string">&quot;vt4I9dOJTAC8g7VY3Z__CA&quot;</span>,<br>                <span class="hljs-attr">&quot;version&quot;</span>: &#123;<br>                    <span class="hljs-attr">&quot;created&quot;</span>: <span class="hljs-string">&quot;7080099&quot;</span><br>                &#125;,<br>                <span class="hljs-attr">&quot;provided_name&quot;</span>: <span class="hljs-string">&quot;shopping&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>查看所有索引</strong></p><p>GET  <a href="http://localhost:9200/_cat/indices?v">http://localhost:9200/_cat/indices?v</a></p><p>health status index          uuid                                         pri    rep     docs.count   docs.deleted       store.size   pri.store.size<br>yellow open   shopping   vt4I9dOJTAC8g7VY3Z__CA   1       1           0                                0                   208b             208b</p><p>health 当前服务器健康状态： green(集群完整) yellow(单点正常、集群不完整) red(单点不正常)</p><p> status 索引打开、关闭状态 </p><p>index 索引名</p><p> uuid 索引统一编号</p><p> pri 主分片数量</p><p> rep 副本数量 </p><p>docs.count 可用文档数量 </p><p>docs.deleted 文档删除状态（逻辑删除）</p><p> store.size 主分片和副分片整体占空间大小 </p><p>pri.store.size 主分片占空间大小</p><ul><li><strong>文档操作</strong></li></ul><p>创建/删除/查询/修改文档</p><p>POST/DELETE/GET/POST<a href="http://localhost:9200/shopping/phone/1001">http://localhost:9200/shopping/phone/1001</a></p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;_index&quot;</span>: <span class="hljs-string">&quot;shopping&quot;</span>, <span class="hljs-comment">//索引名</span><br>    <span class="hljs-attr">&quot;_type&quot;</span>: <span class="hljs-string">&quot;phone&quot;</span>,     <span class="hljs-comment">//文档名</span><br>    <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-string">&quot;1001&quot;</span>,        <span class="hljs-comment">//文档id，类似mysql主键</span><br>    <span class="hljs-attr">&quot;_version&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;result&quot;</span>: <span class="hljs-string">&quot;created&quot;</span>, <span class="hljs-comment">//创建成功</span><br>    <span class="hljs-attr">&quot;_shards&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;total&quot;</span>: <span class="hljs-number">2</span>,       <span class="hljs-comment">//分片总数 2</span><br>        <span class="hljs-attr">&quot;successful&quot;</span>: <span class="hljs-number">1</span>,  <span class="hljs-comment">//分片成功1</span><br>        <span class="hljs-attr">&quot;failed&quot;</span>: <span class="hljs-number">0</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;_seq_no&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;_primary_term&quot;</span>: <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>映射操作</strong>（相当于数据库的表结构）</li></ul><p>根据是否自动识别映射类型，我们可以将映射分为<strong>动态映射</strong>和<strong>静态映射</strong>。</p><p><strong>动态映射</strong>，即不事先指定映射类型(Mapping)，文档写入ElasticSearch时，ES会根据文档字段自动识别类型，这种机制称之为动态映射。</p><p><strong>静态映射</strong>，即人为事先定义好映射，包含文档的各个字段及其类型等，这种方式称之为静态映射，亦可称为显式映射。</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br> <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;name&quot;</span>:&#123;               <span class="hljs-comment">//字段名</span><br> <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,        <span class="hljs-comment">// 字段类型， text：可分词，keyword不可分词</span><br> <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">true</span>          <span class="hljs-comment">//是否被索引  默认被索引</span><br> &#125;,<br> <span class="hljs-attr">&quot;sex&quot;</span>:&#123;<br> <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br> <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br> &#125;,<br> <span class="hljs-attr">&quot;age&quot;</span>:&#123;<br> <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>,<br> <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br> &#125;<br> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><strong>高级查询</strong></li></ul><p><a href="http://127.0.0.1:9200/student/_search">http://127.0.0.1:9200/student/_search</a></p><p>Elasticsearch 提供了基于 JSON 提供完整的查询 DSL 来定义查询</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">//match 匹配类型查询，会把查询条件进行分词，然后进行查询，多个词条之间是 or 的关系</span><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;match&quot;</span>: &#123;              <span class="hljs-comment">//&quot;match_all&quot;:&#123;&#125; 匹配全部</span><br> <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;zhangsan&quot;</span><br> &#125;<br> &#125;<br>&#125;<br><span class="hljs-comment">//multi_match 与 match 类似，不同的是它可以在多个字段中查询。</span><br><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;multi_match&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br> <span class="hljs-attr">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>]<br> &#125;<br> &#125;<br>&#125;<br><span class="hljs-comment">//term 查询，精确的关键词匹配查询，不对查询条件进行分词。</span><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>         <span class="hljs-comment">//&quot;name&quot;: [&quot;zhangsan&quot;,&quot;lisi&quot;]  多关键字精准查询</span><br><br> &#125;<br> &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">//_source 指定查询字段   只返回name ，nickname字段信息</span><br>&#123;<br> <span class="hljs-attr">&quot;_source&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;includes&quot;</span>: [<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>]     <span class="hljs-comment">//查询信息只包含</span><br>  <span class="hljs-string">&quot;excludes&quot;</span>: [<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;nickname&quot;</span>]     <span class="hljs-comment">//查询信息排除字段</span><br> &#125;,<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;terms&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;nickname&quot;</span>: [<span class="hljs-string">&quot;zhangsan&quot;</span>]<br> &#125;<br> &#125;<br>&#125;<br><span class="hljs-comment">//联合查询`bool`把各种其它查询通过`must`（必须 ）、`must_not`（必须不）、`should`（应该）的方式进行组合</span><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;must&quot;</span>: [<br> &#123;<br> <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span><br> &#125;<br> &#125;<br> ],<br> <span class="hljs-attr">&quot;must_not&quot;</span>: [<br> &#123;<br> <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-string">&quot;40&quot;</span><br> &#125;<br> &#125;<br> ],<br> <span class="hljs-attr">&quot;should&quot;</span>: [<br> &#123;<br> <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span><br> &#125;<br> &#125;<br> ]<br> &#125;<br> &#125;<br>&#125;<br><span class="hljs-comment">//范围查询 range  查询找出那些落在指定区间内的数字或者时间。range 查询允许以下字符操作符 说明</span><br> gt 大于&gt;<br> gte 大于等于&gt;=<br> lt 小于&lt;<br> lte 小于等于&lt;=<br><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;age&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;gte&quot;</span>: <span class="hljs-number">30</span>,<br> <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-number">35</span><br> &#125;<br> &#125;<br> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>模糊查询  fuzzy</p><p>为了找到相似的术语，fuzzy 查询会在指定的编辑距离内创建一组搜索词的所有可能的变体 或扩展。然后查询返回每个扩展的完全匹配。 通过 fuzziness 修改编辑距离。一般使用默认值 AUTO，根据术语的长度生成编辑距离。</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;fuzzy&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;title&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span><br> &#125;<br> &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">//排序，单字段多字段均可</span><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br> &#125;,<br> <span class="hljs-attr">&quot;sort&quot;</span>: [<br> &#123;<br> <span class="hljs-attr">&quot;age&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br> &#125;<br> &#125;,<br> &#123;<br> <span class="hljs-attr">&quot;_score&quot;</span>:&#123;<br> <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br> &#125;<br> &#125;<br> ]<br>&#125;<br><br><span class="hljs-comment">//高亮查询</span><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;zhangsan&quot;</span><br> &#125;<br> &#125;,<br> <span class="hljs-attr">&quot;highlight&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;font color=&#x27;red&#x27;&gt;&quot;</span>,  <span class="hljs-comment">//前置标签和后置标签指定高亮格式</span><br> <span class="hljs-attr">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/font&gt;&quot;</span>,<br> <span class="hljs-attr">&quot;fields&quot;</span>: &#123;                         <span class="hljs-comment">//指定name字段高亮显示</span><br> <span class="hljs-attr">&quot;name&quot;</span>: &#123;&#125;<br> &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">//分页查询</span><br><br><span class="hljs-comment">//from：当前页的起始索引，默认从 0 开始。 from = (pageNum - 1) * size</span><br><span class="hljs-comment">//size：每页显示多少条</span><br>&#123;<br> <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br> &#125;,<br> <span class="hljs-attr">&quot;sort&quot;</span>: [<br> &#123;<br> <span class="hljs-attr">&quot;age&quot;</span>: &#123;<br> <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br> &#125;<br> &#125;<br> ],<br> <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-number">0</span>,<br> <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-comment">//聚合查询，相当于groupby</span><br><br>&#123;<br> <span class="hljs-attr">&quot;aggs&quot;</span>:&#123;<br> <span class="hljs-attr">&quot;max_age&quot;</span>:&#123;            <span class="hljs-comment">//对年龄聚合求最大</span><br> <span class="hljs-attr">&quot;max&quot;</span>:&#123;<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;age&quot;</span>&#125;<br> &#125;<br> &#125;,<br> <span class="hljs-attr">&quot;size&quot;</span>:<span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//stats 聚合，对某个字段一次性返回 count，max，min，avg 和 sum 五个指标</span><br>&#123;<br> <span class="hljs-attr">&quot;aggs&quot;</span>:&#123;<br> <span class="hljs-attr">&quot;stats_age&quot;</span>:&#123;<br> <span class="hljs-attr">&quot;stats&quot;</span>:&#123;<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;age&quot;</span>&#125;<br> &#125;<br> &#125;,<br> <span class="hljs-attr">&quot;size&quot;</span>:<span class="hljs-number">0</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="Java-Api"><a href="#Java-Api" class="headerlink" title="Java Api"></a>Java Api</h3><p>TODO…</p><h2 id="ES高级"><a href="#ES高级" class="headerlink" title="ES高级"></a>ES高级</h2><h3 id="集群配置文件"><a href="#集群配置文件" class="headerlink" title="集群配置文件"></a>集群配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># ---------------------------------- Cluster -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use a descriptive name for your cluster:</span><br><span class="hljs-comment">#集群名称，节点间一致，加入相同名称的集群</span><br><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">my-application</span><br><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ------------------------------------ Node ------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use a descriptive name for the node:</span><br><span class="hljs-comment">#节点名称，集群内唯一</span><br><span class="hljs-attr">node.name:</span> <span class="hljs-string">node-9202</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Add custom attributes to the node:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#node.attr.rack: r1</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ----------------------------------- Paths ------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="hljs-comment">#可以指定es的数据存储目录，默认存储在es_home/data目录下</span><br><span class="hljs-comment">#path.data: /path/to/data</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Path to log files:</span><br><span class="hljs-comment">#可以指定es的日志存储目录，默认存储在es_home/logs目录下</span><br><span class="hljs-comment">#path.logs: /path/to/logs</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ----------------------------------- Memory -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Lock the memory on startup:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#bootstrap.memory_lock: true</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Make sure that the heap size is set to about half the memory available</span><br><span class="hljs-comment"># on the system and that the owner of the process is allowed to use this</span><br><span class="hljs-comment"># limit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Elasticsearch performs poorly when the system is swapping the memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ---------------------------------- Network -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#network.host: 192.168.0.1</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set a custom port for HTTP:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#http.port: 9200</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information, consult the network module documentation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-string">localhost</span><br><span class="hljs-comment">#http 端口 对外提供服务端口</span><br><span class="hljs-attr">http.port:</span> <span class="hljs-number">9202</span><br><span class="hljs-comment">#tcp 监听端口 集群建交互端口</span><br><span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9302</span><br><span class="hljs-comment"># --------------------------------- Discovery ----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Pass an initial list of hosts to perform discovery when this node is started:</span><br><span class="hljs-comment"># The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Bootstrap the cluster using an initial set of master-eligible nodes:</span><br><span class="hljs-comment">#集群内的可以被选为主节点的节点列表</span><br><span class="hljs-comment">#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information, consult the discovery and cluster formation module documentation.</span><br><span class="hljs-comment">#查找主节点，内部通信端口9300</span><br><span class="hljs-attr">discovery.seed_hosts:</span> [<span class="hljs-string">&quot;localhost:9300&quot;</span>]<br><span class="hljs-attr">discovery.zen.fd.ping_timeout:</span> <span class="hljs-string">1m</span><br><span class="hljs-attr">discovery.zen.fd.ping_retries:</span> <span class="hljs-number">5</span><br><span class="hljs-comment"># ---------------------------------- Gateway -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Block initial recovery after a full cluster restart until N nodes are started:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#gateway.recover_after_nodes: 3</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information, consult the gateway module documentation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ---------------------------------- Various -----------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Require explicit names when deleting indices:</span><br><span class="hljs-comment">#跨域配置</span><br><span class="hljs-comment">#action.destructive_requires_name: true</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></div></td></tr></table></figure><p>分片副本设置</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123; <span class="hljs-attr">&quot;settings&quot;</span> : &#123; <span class="hljs-attr">&quot;number_of_shards&quot;</span> : <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;number_of_replicas&quot;</span> : <span class="hljs-number">1</span> &#125; &#125;<br></code></pre></div></td></tr></table></figure><p><img src="C:\Users\22106\AppData\Roaming\Typora\typora-user-images\image-20210725225029058.png" alt="image-20210725225029058"></p><h3 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>索引(index)</li></ul><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的 索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必 须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时 候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。 能搜索的数据必须索引，这样的好处是可以提高查询速度。</p><ul><li>文档(document)</li></ul><p>一个文档是一个可被索引的基础信息单元，也就是一条数据 比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个 订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个 到处存在的互联网数据交互格式。 在一个 index/type 里面，你可以存储任意多的文档。</p><ul><li>字段（Field） </li></ul><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。</p><ul><li>映射（Mapping）</li></ul><p> mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、 分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一 些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射， 并且需要思考如何建立映射才能对性能更好。</p><ul><li>分片（Shards）</li></ul><p> 一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据 的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。或者单个节点处 理搜索请求，响应太慢。为了解决这个问题，Elasticsearch 提供了将索引划分成多份的能力， 每一份就称之为分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分 片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点 上。</p><p> 分片很重要，主要有两方面的原因：</p><p> 1）允许你水平分割 / 扩展你的内容容量。</p><p> 2）允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。 至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的。</p><p><strong>索引中的分片数量一旦确定就不能更改</strong>  shard = hash(routing) % number_of_primary_shards</p><p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p><ul><li>副本（Replicas） </li></ul><p>在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于 离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是 强烈推荐的。为此目的，Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复 制分片(副本)。</p><p> 复制分片之所以重要，有两个主要原因： </p><p>1)在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与 原/主要（original/primary）分片置于同一节点上是非常重要的。</p><ol start="2"><li>扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。</li></ol><ul><li>Lucene </li></ul><p>一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个 Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询 到每一个属于索引的分片(Lucene 索引)，然后合并每个分片的结果到一个全局的结果集。</p><p>每个分片都是一个 Lucene 索引实例，您可以将其视作一个独立的搜索引擎，它能够对 Elasticsearch 集群中的数据子集进行索引并处理相关查询；每个分片包含多个segment（段），每一个segment都是一个倒排索引。</p><p>在查询时，会把所有的segment查询结果汇总归并为最终的分片查询结果返回。</p><p>倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构。 lucene从4+版本后开始大量使用的数据结构是FST。FST有两个优点：</p><ul><li>1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</li><li>2）查询速度快。O(len(str))的查询时间复杂度。</li></ul><h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml">  <span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><span class="hljs-string">/false</span>       <span class="hljs-string">//a是否可被选为master</span><br>  <span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><span class="hljs-string">/false</span>        <span class="hljs-string">//是否为数据节点</span><br><br><span class="hljs-attr">discovery.zen.ping.unicast.hosts:</span> [<span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>, <span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>, <span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span>]  <span class="hljs-string">//</span> <span class="hljs-string">发现地址</span><br><br><span class="hljs-attr">discovery.zen.minimum_master_nodes:</span> <span class="hljs-number">2</span>                        <span class="hljs-string">//候选节点足够才可以选出master</span><br><span class="hljs-string">//只有足够的master候选节点时，才可以选举出一个master。该参数必须设置为集群中master候选节点的quorum数量。</span><br></code></pre></div></td></tr></table></figure><p> 假设有ABC三个候选节点，此时集群中没有master，</p><ul><li>第一步：确认候选主节点数达标，elasticsearch.yml设置的值discovery.zen.minimum_master_nodes；</li><li>第二步：比较：先判定是否具备master资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，先根据节点的clusterStateVersion比较，clusterStateVersion越大，优先级越高。clusterStateVersion相同时，进入compareNodes，其内部按照节点的Id比较(Id为节点第一次启动时随机生成)。</li></ul><h3 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h3><p><strong>近实时搜索</strong></p><p>Lucene 允许新段被写入和打开——使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p><p>每次写入先写入到缓冲区，同时写入translog(5s写入磁盘一次，会丢失5s数据) ， 刷新时刷新入段（refresh—-&gt;segment），缓冲区被清除，事务日志不会被删除，此时的数据可以被索引到，多个段合并时删除 .del文件中被标记删除的记录，随着translog日志增大（30分钟），执行flush，一个commit被执行，translog清空，一个全量提交被执行。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73d399dcf6ac48078d964a2295e79838~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><ul><li>Elasticsearch会把数据先写入内存缓冲区，然后每隔<strong>1s</strong>刷新到文件系统缓存区（当数据被刷新到文件系统缓冲区以后，数据才可以被检索到）。所以：Elasticsearch写入的数据需要<strong>1s</strong>才能查询到</li><li>为了防止节点宕机，内存中的数据丢失，Elasticsearch会另写一份数据到<strong>日志文件</strong>上，但最开始的还是写到内存缓冲区，每隔<strong>5s</strong>才会将缓冲区的刷到磁盘中。所以：Elasticsearch某个节点如果挂了，可能会造成有<strong>5s</strong>的数据丢失。</li><li>等到磁盘上的translog文件大到一定程度或者超过了30分钟，会触发<strong>commit</strong>操作，将内存中的segement文件异步刷到磁盘中，完成持久化操作。</li></ul><p><strong>Translog</strong></p><p>translog 也被用来提供实时 CRUD 。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前， 首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p><p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候， 它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。</p><p>在重启节点或关闭索引之前执行flush有益于你的索引。当 Elasticsearch 尝试恢复或重新打开一个索引， 它需要重放 translog 中所有的操作，所以如果日志越短，恢复越快。</p><p><strong>写入优化</strong></p><p>使用bulk api批量操作</p><p>调整refresh_interval的间隔，es在每一次refresh时都会创建lucene的segment，并尝试进行segment的合并，开销较大，若对搜索的实时性要求不高，可以适当的调大refresh_interval的大小</p><p>不需要索引的字段指定index属性为not_analyzed</p><p><code>optimize</code> API大可看做是 <em>强制合并</em> API。它会将一个分片强制合并到 <code>max_num_segments</code> 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p><strong>QUERY_THEN_FETCH</strong>总体的流程流程大概是：</p><ul><li>客户端请求发送到集群的某个节点上。集群上的每个节点都是coordinate node（协调节点）</li><li>然后协调节点将搜索的请求转发到<strong>所有分片上</strong>（主分片和副本分片都行）</li><li>每个分片将自己搜索出的结果<code>(doc id)</code>返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li></ul><p><strong>Query Phase阶段</strong>时节点做的事：</p><ul><li>协调节点向目标分片发送查询的命令（转发请求到主分片或者副本分片上）</li><li>数据节点（在每个分片内做过滤、排序等等操作），返回<code>doc id</code>给协调节点</li></ul><p><strong>Fetch Phase阶段</strong>时节点做的是：</p><ul><li>协调节点得到数据节点返回的<code>doc id</code>，对这些<code>doc id</code>做聚合，然后将目标数据分片发送抓取命令（希望拿到整个Doc记录）</li><li>数据节点按协调节点发送的<code>doc id</code>，拉取实际需要的数据返回给协调节点</li></ul><p><img src="C:\Users\22106\AppData\Roaming\Typora\typora-user-images\image-20210802220137747.png" alt="image-20210802220137747"></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>深度分页</p><ul><li>必备：对排序字段，筛选条件务必设置好索引</li><li>核心：利用小范围页码的已知数据，或者滚动加载的已知数据，减少偏移量</li><li>额外：如果遇到不好处理的情况，也可以获取多余的数据，进行一定的截取，性能影响并不大</li></ul><p>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。</p><p>SQL 优化</p><p>select * from task_result LIMIT 20000000, 10;</p><p>SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10（id为主键走索引缩小范围） b where a.id = b.id;再查全部字段，只有十条，再回表。</p><p>ES分页</p><p><code>scroll</code> 查询 可以用来对 Elasticsearch 有效地执行大批量的文档查询，而又不用付出深度分页那种代价。</p><p>游标查询允许我们 先做查询初始化，然后再批量地拉取结果。 这有点儿像传统数据库中的 <em>cursor</em> 。</p><p>游标查询会取某个时间点的快照数据。 查询初始化之后索引上的任何变化会被它忽略。 它通过保存旧的数据文件来实现这个特性，结果就像保留初始化时的索引 <em>视图</em> 一样。</p><p>深度分页的代价根源是结果集全局排序，如果去掉全局排序的特性的话查询结果的成本就会很低。 游标查询用字段 <code>_doc</code> 来排序。 这个指令让 Elasticsearch 仅仅从还有结果的分片返回下一批结果。所以针对大数据量的查询，要使用 scroll。这种方式相当于建立了一个游标，标记当前的读取位置，保证下一次查询快速取出数据。</p><ul><li>针对这次请求将符合条件的所有结果汇集到协调节点缓存起来，后续直接从协调节点的缓存中取出</li><li>由于缓存的存在，文档后续的变更并不会同步到缓存中，并不适合实时请求</li><li>同样因为缓存的数据量为query命中的所有doc，所以scroll的堆内存开销是非常大的，要及时删除scroll_id。</li><li>适用于索引的重建/数据的迁移等非实时、低频的场景。</li></ul><p>search_after</p><ul><li>使用上一页的检索结果来帮助检索下一页，排序字段里要包括doc的唯一标识，以保证search_after的一致性</li><li>每一个shard请求的数据集大小为size</li><li>不支持随机分页访问</li><li>实时处理，若doc有变更且影响到了排序因子，有可能出现重复数据</li></ul><p>基于offset的分页</p><ul><li>from + size，from指定偏移量，size指定要取的数据条数</li><li>执行原理：</li></ul><ol><li>client发起请求，收到请求的shard成为协调节点，负责后续请求数据的合并</li><li>执行query，取到from+size大小的结果集，协调节点本地构建构建大小为from+size的priority queue ，协调节点将请求分发到其他shard</li><li>其他shard 同样执行query，取到from+size大小的结果集，将集合返给协调节点</li><li>协调节点合并结果集，最后得到from+size大小的priority queue，将后size个数据返给client</li></ol><h3 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h3><p>ES索引数据过多</p><h4 id="动态索引层面"><a href="#动态索引层面" class="headerlink" title="动态索引层面"></a>动态索引层面</h4><p>基于<code>模板+时间+rollover api滚动</code>创建索引，举例：设计阶段定义：blog索引的模板格式为：blog_index_时间戳的形式，每天递增数据。</p><p>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线2的32次幂-1，索引存储达到了TB+甚至更大。</p><p>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p><h4 id="存储层面"><a href="#存储层面" class="headerlink" title="存储层面"></a>存储层面</h4><p><code>冷热数据分离存储</code>，热数据（比如最近3天或者一周的数据），其余为冷数据。 对于冷数据不会再写入新数据，可以考虑定期force_merge加shrink压缩操作，节省存储空间和检索效率。</p><h4 id="部署层面"><a href="#部署层面" class="headerlink" title="部署层面"></a>部署层面</h4><p>一旦之前没有规划，这里就属于应急策略。 结合ES自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意：如果之前主节点等<code>规划合理</code>，不需要重启集群也能完成动态新增的。</p><p>我们当前的选择只有一个就是将数据重新索引至一个拥有更多分片的一个更大的索引，但这样做将消耗的时间是我们无法提供的。 通过事先规划，我们可以使用 <em>预分配</em> 的方式来完全避免这个问题。</p><p> Elasticsearch 不支持 <em>分片分裂（shard-splitting）</em>— 将每个分片分裂为两个或更多部分的能力。 </p><ul><li>分裂一个分片几乎等于重新索引你的数据。它是一个比仅仅将分片从一个节点复制到另一个节点更重量级的操作。</li><li>分裂是指数的。起初你你有一个分片，然后分裂为两个，然后四个，八个，十六个，等等。分裂并不会刚好地把你的处理能力提升 50%。</li><li>分片分裂需要你拥有足够的能力支撑另一份索引的拷贝。通常来说，当你意识到你需要横向扩展时，你已经没有足够的剩余空间来做分裂了。</li><li>尽管可以增加新的类型到索引中，或者增加新的字段到类型中，但是不能添加新的分析器或者对现有的字段做改动。 如果你那么做的话，结果就是那些已经被索引的数据就不正确， 搜索也不能正常工作。</li></ul><p>对现有数据的这类改变最简单的办法就是重新索引：用新的设置创建新的索引并把文档从旧的索引复制到新的索引。</p><p>字段 <code>_source</code> 的一个优点是在Elasticsearch中已经有整个文档。你不必从源数据中重建索引，而且那样通常比较慢。</p><p>为了有效的重新索引所有在旧的索引中的文档，用 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html"><em>scroll</em></a> 从旧的索引检索批量文档 ， 然后用 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/bulk.html"><code>bulk</code> API</a>把文档推送到新的索引中。</p><p>从Elasticsearch v2.3.0开始，Reindex 被引入。它能够对文档重建索引而不需要任何插件或外部工具。</p><p>Reindex 不会尝试设置目标索引。它不会复制源索引的设置。应该在运行<code>_reindex</code>操作之前设置目标索引，包括设置映射、分片计数、副本等。</p><p><strong>索引别名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sense">PUT /my_index_v1 <br>PUT /my_index_v1/_alias/my_index <br></code></pre></div></td></tr></table></figure><table><thead><tr><th></th><th>创建索引 <code>my_index_v1</code> 。</th></tr></thead><tbody><tr><td></td><td>设置别名 <code>my_index</code> 指向 <code>my_index_v1</code> 。</td></tr></tbody></table><p>一个别名可以指向多个索引，所以我们在添加别名到新索引的同时必须从旧的索引中删除它。这个操作需要原子化，这意味着我们需要使用 <code>_aliases</code> 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sense">POST /_aliases<br>&#123;<br>    &quot;actions&quot;: [<br>        &#123; &quot;remove&quot;: &#123; &quot;index&quot;: &quot;my_index_v1&quot;, &quot;alias&quot;: &quot;my_index&quot; &#125;&#125;,<br>        &#123; &quot;add&quot;:    &#123; &quot;index&quot;: &quot;my_index_v2&quot;, &quot;alias&quot;: &quot;my_index&quot; &#125;&#125;<br>    ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>你的应用已经在零停机的情况下从旧索引迁移到新索引了。</p><p>应用中使用别名而不是索引名。然后你就可以在任何时候重建索引。别名的开销很小，应该广泛使用。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><strong>文件描述符</strong></p><p>Lucene 使用了 <em>大量的</em> 文件。 同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字（注：sockets）。 所有这一切都需要足够的文件描述符。</p><p>许多现代的 Linux 发行版本，每个进程默认允许一个微不足道的 1024 文件描述符。这对一个小的 Elasticsearch 节点来说实在是太 <em>低</em> 了，更不用说一个处理数以百计索引的节点。</p><p>你应该增加你的文件描述符，设置一个很大的值，如 64,000。这个过程困难得让人恼火，它高度依赖于你的特定操作系统和分布。请参考你操作系统文档来确定如何最好地修改允许的文件描述符数量。</p><p>一旦你认为已经改变了它，检查 Elasticsearch，以确保它的真的起作用并且有足够的文件描述符：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">GET /_nodes/process<br></code></pre></div></td></tr></table></figure><p><strong>内存映射</strong></p><p>Elasticsearch 对各种文件混合使用了 NioFs（ 注：非阻塞文件系统）和 MMapFs （ 注：内存映射文件系统）。请确保你配置的最大映射数量，以便有足够的虚拟内存可用于 mmapped 文件。</p><p><strong>部署环境</strong></p><ul><li>1）关闭缓存swap;</li><li>2）堆内存设置为：Min（节点内存/2, 32GB）;</li><li>3)设置最大文件句柄数；</li><li>4）线程池+队列大小根据业务需要做调整；</li><li>5）磁盘存储raid方式——存储有条件使用RAID10，增加单节点性能以及避免单节点存储故障。</li></ul><p>1.1、设计阶段调优</p><ul><li>1）根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引；</li><li>2）使用别名进行索引管理；</li><li>3）每天凌晨定时对索引做force_merge操作，以释放空间；</li><li>4）采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储；</li><li>5）采取curator进行索引的生命周期管理；</li><li>6）仅针对需要分词的字段，合理的设置分词器；</li><li>7）Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。 ……..</li></ul><p>1.2、写入调优</p><ul><li>1）写入前副本数设置为0；</li><li>2）写入前关闭refresh_interval设置为-1，禁用刷新机制；</li><li>3）写入过程中：采取bulk批量写入；</li><li>4）写入后恢复副本数和刷新间隔；</li><li>5）尽量使用自动生成的id。</li></ul><p>1.3、查询调优</p><ul><li>1）禁用wildcard；</li><li>2）禁用批量terms（成百上千的场景）；</li><li>3）充分利用倒排索引机制，能keyword类型尽量keyword；</li><li>4）数据量大时候，可以先基于时间敲定索引再检索；</li><li>5）设置合理的路由机制。</li></ul>]]></content>
    
    
    <categories>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中间件</tag>
      
      <tag>ES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程并发问题</title>
    <link href="/2021/06/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e532817f707795?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>新建状态（ NEW）：</strong> 线程刚创建, 尚未启动。<code>Thread thread = new Thread()</code>。</p><p><strong>可运行状态（RUNNABLE）：</strong> 线程对象创建后，其他线程(比如 main 线程）调用了该对象的 <code>start</code> 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。</p><p><strong>运行(running)：</strong> 线程获得 CPU 资源正在执行任务（<code>run()</code> 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p><p><strong>阻塞状态（Blocked）：</strong> 线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。</p><p><code>sleep</code>,<code>suspend</code>，<code>wait</code>等方法都可以导致线程阻塞。</p><p><strong>等待（WAITING）：</strong> 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p><strong>超时等待(TIMED_WAITING)：</strong> 该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</p><p><strong>终止(TERMINATED)：</strong> 表示该线程已经执行完毕，如果一个线程的<code>run</code>方法执行结束或者调用<code>stop</code>方法后，该线程就会死亡。对于已经死亡的线程，无法再使用<code>start</code>方法令其进入就绪。</p><h3 id="创建线程方式"><a href="#创建线程方式" class="headerlink" title="创建线程方式"></a>创建线程方式</h3><p>实现Runnable接口，重载<code>run()</code>，无返回值</p><p>继承Thread类，复写<code>run()</code></p><p>实现Callable接口，通过FutureTask/Future来创建有返回值的Thread线程，通过Executor执行</p><p>使用Executors创建ExecutorService，入参Callable或Future</p><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul><li>进程是资源申请、调度和独立运行的单位，是一个程序在其自身的地址空间中的一次执行活动,是系统运行程序的基本单位</li><li>线程又称为轻量级进程，它和进程一样拥有独立的执行控制，由操作系统负责调度，区 别在于线程没有独立的存储空间，而是和所属进程中的其它线程共享一个存储空间，这使得线程间的通信远较进程简单。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。（多个线程共享一个进程的堆和方法区）</li></ul><h3 id="Voliate"><a href="#Voliate" class="headerlink" title="Voliate"></a>Voliate</h3><p><strong>保证可见性</strong></p><blockquote><ol><li><p>当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中</p></li><li><p>这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见。</p><p>（它会强制<strong>将缓存的修改操作立即写到主内存</strong>，写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。）</p></li></ol></blockquote><p>volatile之所以具有可见性，是因为底层中的Lock指令，该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</p><p><strong>禁止指令重排序</strong></p><p>volatile之所以能防止指令重排序，是因为Java编译器对于volatile修饰的变量，会插入内存屏障。内存屏障会防止CPU处理指令的时候重排序的问题。</p><p>在每个volatile写操作的前面插入一个storestore屏障。</p><p>在每个volatile写操作的后面插入一个storeload屏障。</p><p>在每个volatile读操作的后面插入一个loadload屏障。</p><p>在每个volatile读操作的后面插入一个loadstore屏障。</p><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p><strong>不具有原子性</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">x = <span class="hljs-number">10</span>;         <span class="hljs-comment">//单个操作，具有原子性</span><br>x++;            <span class="hljs-comment">//多个操作（读取x的值，将x的值+1，赋值给x），不具有原子性</span><br></code></pre></div></td></tr></table></figure><p>在有多个操作的情况下，CPU任然可以先暂停然后在调度的。既然能被暂停后继续在调度，那么volatile肯定是不具备原子性的了。</p><h1 id="多线程带来的问题"><a href="#多线程带来的问题" class="headerlink" title="多线程带来的问题"></a>多线程带来的问题</h1><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><p>所有线程的共享变量都存储在主内存中，每一个线程都有一个独有的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己的工作内存中，只操作工作内存中的数据。当修改完毕后，再把修改后的结果放回到主内存中。每个线程都只操作自己工作内存中的变量，无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p>如果有AB两个线程同时拿到变量i，进行递增操作。A线程将变量i放到自己的工作内存中，然后做+1操作，然而此时，线程A还没有将修改后的值刷回到主内存中，而此时线程B也从主内存中拿到修改前的变量i，也进行了一遍+1的操作。最后A和B线程将各自的结果分别刷回到主内存中，看到的结果就是变量i只进行了一遍+1的操作，而实际上A和B进行了两次累加的操作，于是就出现了错误。</p><h3 id="时序操作"><a href="#时序操作" class="headerlink" title="时序操作"></a>时序操作</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>    map.remove(obj)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>代码中首先检查 map 中有没有 key 对应的元素，如果有则继续执行 remove 操作。此时，这个组合操作就是危险的，因为它是先检查后操作，而执行过程中可能会被打断。如果此时有两个线程同时进入 if() 语句，然后它们都检查到存在 key 对应的元素，于是都希望执行下面的 remove 操作，随后一个线程率先把 obj 给删除了，而另外一个线程它刚已经检查过存在 key 对应的元素，if 条件成立，所以它也会继续执行删除 obj 的操作，但实际上，集合中的 obj 已经被前面的线程删除了，这种情况下就可能导致线程安全问题。</p><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p><strong>死锁产生的原因</strong></p><p>• 互斥条件：线程要求对所分配的资源进行排他性控制,即在一段时间内某 资源仅为一个进程所占有.此时若有其他进程请求该资源.则请求进程只能等待.</p><p>• 不剥夺条件：进程所获得的资源在未使用完毕之前,不能被其他进程强行夺走,即只能由获得该资源的线程自己来释放（只能是主动释放).</p><p>• 请求和保持条件：线程已经保持了至少一个资源,但又提出了新的资源请求,而该资源已被其他线程占有,此时请求线程被阻塞,但对自己已获得的资源保持不放.</p><p>• 循环等待条件：存在一种线程资源的循环等待链,链中每一个线程已获得的资源同时被链中下一个线程所请求。</p><p>死锁的定义：“死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。”</p><p>一个更加规范的定义：“集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。”</p><p>竞争的资源可以是：锁、网络连接、通知事件，磁盘、带宽，以及一切可以被称作“资源”的东西。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">final</span> Object a=<span class="hljs-keyword">new</span> Object();<br>        <span class="hljs-keyword">final</span> Object b=<span class="hljs-keyword">new</span> Object();<br><br>        Thread ta=<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>          <span class="hljs-keyword">synchronized</span> (a)&#123;<br>          <span class="hljs-keyword">try</span>&#123;<br>              System.out.println(<span class="hljs-string">&quot;线程a得到对象a上的锁&quot;</span>);<br>              Thread.sleep(<span class="hljs-number">1000</span>);<br>              <span class="hljs-keyword">synchronized</span> (b)&#123;<br>                  System.out.println(<span class="hljs-string">&quot;线程a获取b对象上的锁&quot;</span>);<br>              &#125;<br>          &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>              e.printStackTrace();<br>          &#125;<br>          &#125;<br>        &#125;);<br>        Thread tb=<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>          <span class="hljs-keyword">synchronized</span> (b)&#123;<br>          <span class="hljs-keyword">try</span>&#123;<br>              System.out.println(<span class="hljs-string">&quot;线程b得到对象b上的锁&quot;</span>);<br>              Thread.sleep(<span class="hljs-number">1000</span>);<br>              <span class="hljs-keyword">synchronized</span> (a)&#123;<br>                  System.out.println(<span class="hljs-string">&quot;线程b获取a对象上的锁&quot;</span>);<br>              &#125;<br>          &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>              e.printStackTrace();<br>          &#125;<br>          &#125;<br>        &#125;);<br>        ta.start();<br>        tb.start();<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>死锁排查</strong></p><p>1.jps命令查看进程号</p><p>jps<br>15188<br>11916 Launcher<br><strong>15404 DeadLock</strong><br>6988 Jps</p><p>2.jstack 查看堆栈信息，</p><p>E:\Ideaworkspace\Daily-leetcode&gt;<strong>jstack -F 15404</strong><br>Attaching to process ID 15404, please wait…<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is 25.261-b12<br>Deadlock Detection:</p><p>Found one Java-level deadlock:</p><p>“Thread-1”:<br>  waiting to lock Monitor@0x0000029284659c38 (Object@0x00000000d6006170, a java/lang/Object),<br>  which is held by “Thread-0”<br>“Thread-0”:<br>  waiting to lock Monitor@0x000002928465c628 (Object@0x00000000d6006180, a java/lang/Object),<br>  which is held by “Thread-1”</p><p>Found a total of 1 deadlock.</p><p>3.jconsole </p><p><strong>死锁预防</strong></p><p>1.以确定的顺序获得锁</p><p>2.超时放弃</p><p>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了<code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code>方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文 是指某一时间点 CPU 寄存器和程序计数器的内容</p><p>1.挂起一个线程 ，将这个线程程在 CPU 中的状态（上下文）存储于内存中的某处；</p><p>2.恢复一个线程，在内存中检索下一个线程的上下文并将其在 CPU 的寄存器中恢复；</p><p>3.跳转到程序计数器所指向的位置，（即跳转到线程被中断时的代码行），以恢复该线程。</p><ul><li><p>减少上下文切换的手段</p><blockquote><p>1.<strong>减少锁等待</strong>：锁等待意味着，线程频繁在活跃与等待状态之间切换，增加上下文切换，锁等待是由对同一份资源竞争激烈引起的，在一些场景我们可以用一些手段减轻锁竞争，比如<strong>数据分片</strong>或者数据快照等方式。</p><p>2.<strong>CAS算法</strong>：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；</p><p>3.<strong>使用合适的线程数量</strong>：N（thread）=N（cpu） * <strong>U（cpu）</strong>（CPU期望利用率）*（1+W/C)(W/C时等待事件/计算时间)。</p><p><strong>cpu密集型</strong>：加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。CPU个数的1-2倍，</p><p><strong>IO密集型</strong>：数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，远慢于CPU的运算速度，在等待IO时可以让出CPU资源。CPU个数的多倍。</p><p>4.<strong>使用协程</strong>：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；</p></blockquote></li></ul><h3 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h3><p>为提高读取效率，一次读取一个缓存行（64字节）到内存。（局部性原理）多线程情况下要保证缓存一致性。</p><p>Write invalidate（置无效）：当一个内核修改了一份数据，其他内核上如果有这份数据的复制，就置成无效。</p><p>Write update（写更新）：当一个内核修改了一份数据，其他地方如果有这份数据的复制，就都更新到最新值。</p><p><strong>伪共享问题</strong>：</p><p>在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去 竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要 使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p><h3 id="协作开销"><a href="#协作开销" class="headerlink" title="协作开销"></a>协作开销</h3><p>线程协作同样也有可能带来性能问题。因为线程之间如果有共享数据，为了避免数据错乱，为了保证线程安全，就有可能禁止编译器和 CPU 对其进行重排序等优化，也可能出于同步的目的，反复把线程工作内存的数据 flush 到主存中，然后再从主内存 refresh 到其他线程的工作内存中，等等。这些问题在单线程中并不存在，但在多线程中为了确保数据的正确性，就不得不采取上述方法，因为线程安全的优先级要比性能优先级更高，这也间接降低了我们的性能。</p><p>还有就是你在自己的代码实现中，为了线程安全添加了相应的逻辑，从而带来了相应的开销。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类的加载及对象创建分配的过程</title>
    <link href="/2021/06/08/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/06/08/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">int</span> staicVariabl=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//成员变量 （可以不进行初始化，如果进行初始化，成员变量的初始化动作在类层面完成，）</span><br>    <span class="hljs-keyword">public</span>   <span class="hljs-keyword">int</span>  objVariabl;<br><br>    <span class="hljs-comment">//静态初始代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        staicVariabl=<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//对象初始化代码块</span><br>    &#123;<br>        objVariabl=<span class="hljs-number">88</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>        objVariabl=<span class="hljs-number">99</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person person=<span class="hljs-keyword">new</span> Person();<br>    &#125;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="编译加载"><a href="#编译加载" class="headerlink" title="编译加载"></a>编译加载</h3><blockquote><p>经过编译后Person.java 会生成一个Person.class文件。Person.class经过加载后，会把类的相关信息加载到JVM内存中，解析出类的描述信息会保存到Metaspace。</p></blockquote><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p></blockquote><p>文件格式验证，元数据验证，字节码验证，符号引用验证。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p>给静态变量赋默认值，此时staicVariabl=0;准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述。Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。类的元数据（元数据并不是类的Class对象。Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的）才是存在方法区的。</p></blockquote><blockquote><p>这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p></blockquote><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p></blockquote><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标</li><li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li><li>多态的实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span> <span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类方法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sub1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;sub1方法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sub2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;sub2方法&quot;</span>);<br>    &#125;<br>&#125;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Parent parent;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        parent = <span class="hljs-keyword">new</span> sub2();<br>       parent.write();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>编译test类时用到了Parent类，</li><li> 此时不知道Parent类是否被加载，test类中存放了Parent类的符号引用。</li><li>到了test的解析阶段，使用到Parent类时，发现Parent类未被加载，将Parent类进行加载，将Parent的符号引用改为指向实际地址的直接引用。 </li><li>Parent类中有两个实现类，具体的引用该指向谁只有在发生调用时才会确定</li><li>通过后期绑定实现，类的动态解析，多态的具体实现。<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li></ol><blockquote><p>1、首先会对Person类的静态变量staicVariabl 进行真正的赋值的操作（此时staicVariabl =1）。</p></blockquote><blockquote><p>2、然后收集类的静态代码块内容，生成一个类的<clinit>() 方法并执行（此时staicVariabl =2）。</p></blockquote><h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><p>当我们new一个对象的时候JVM首先会去找到对应的类元信息，如果找不到意味着类信息还没有被加载，所以在对象创建的时候也可能会触发类的加载操作。当类元信息被加载之后，我们就可以通过类元信息来确定对象信息和需要申请的内存大小。</p><p>对象创建的流程<br>当我们执行上面代码中main方法中的的 Person person=new Person() 时，我们的对象就开始创建了，执行流程大致分为三步：</p><ol><li><p>构建对象：首先main线程会在栈中申请一个自己的栈空间，然后调用main方法后会生成一个main方法的栈帧。然后执行new Person() ，这里会根据Person类元信息先确定对象的大小，向JVM堆中申请一块内存区域并构建对象，同时对Person对象成员变量信息并赋默认值。</p></li><li><p>初始化对象：然后执行对象内部生成的init方法，初始化成员变量值，同时执行搜集到的{}代码块逻辑，最后执行对象构造方法（init 方法执行完后objVariabl=88，构造方法执行完后objVariabl=99)。</p></li><li><p>引用对象：对象实例化完毕后，再把栈中的Person对象引用地址指向Person对象在堆内存中的地址。</p><p><strong>相应类加载检查过程</strong></p><blockquote><p>遇到new指令时，先检查指令参数是否能在常量池中定位到一个类的符号引用：<br>（A）、如果能定位到，检查这个符号引用代表的类是否已被加载、解析和初始化过；<br>（B）、如果不能定位到，或没有检查到，就先执行相应的类加载过程；</p></blockquote></li></ol><h3 id="在Java堆中为对象分配内存"><a href="#在Java堆中为对象分配内存" class="headerlink" title="在Java堆中为对象分配内存"></a>在Java堆中为对象分配内存</h3><p>   对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p><ul><li><p>内存规整，指针碰撞（Bump The Pointer）<br> 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一<br> 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</p></li><li><p>内存不规整，空闲列表（Free List）<br> 如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</p></li></ul><blockquote><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p></blockquote><p><strong>多线程下分配内存时的冲突问题</strong></p><p>   正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><ul><li><p>CAS<br> 一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</p></li><li><p>TLAB<br> 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p></li></ul><h3 id="分配后内存初始化为零"><a href="#分配后内存初始化为零" class="headerlink" title="分配后内存初始化为零"></a>分配后内存初始化为零</h3><p>   内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="对对象进行必要的设置"><a href="#对对象进行必要的设置" class="headerlink" title="对对象进行必要的设置"></a>对对象进行必要的设置</h3><p>   这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="执行对象实例方法init"><a href="#执行对象实例方法init" class="headerlink" title="执行对象实例方法init"></a>执行对象实例方法init</h3><p>   构造函数，即Class文件中的init()方法还没有执行new指令之后会接着执行init()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p><h2 id="对象在内存中的布局"><a href="#对象在内存中的布局" class="headerlink" title="对象在内存中的布局"></a>对象在内存中的布局</h2><p>   在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>   <img src="https://img-blog.csdnimg.cn/20210412204329726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul><li>Mark Word<br> 于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部<br> 分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。<br> 考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。<br> 例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0<br> <img src="https://img-blog.csdnimg.cn/20210412204409503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ul><li><p>类型指针<br> 对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例</p></li><li><p>数组长度<br> 数组对象才有，用来确定数组的大小。</p></li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>   对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>   仅仅起着占位符的作<br>   用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h2 id="对象访问的定位"><a href="#对象访问的定位" class="headerlink" title="对象访问的定位"></a>对象访问的定位</h2><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>   Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p>   <img src="https://img-blog.csdnimg.cn/20210412204445405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="file"></p><p>   使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><h3 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h3><p>   使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销</p><p>   <img src="https://img-blog.csdnimg.cn/20210412204459434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blbmdib19DaGVuZw==,size_16,color_FFFFFF,t_70" alt="file"></p><p>   使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就HotSpot而言，它主要使用第二种方式进行对象访问。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
